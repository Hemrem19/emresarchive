// Prisma Schema for citavErsa
// Database schema matching BACKEND_PLAN.md specifications

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users Table
model User {
  id              Int       @id @default(autoincrement())
  email           String    @unique
  passwordHash    String    @map("password_hash")
  name            String?
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  emailVerified   Boolean   @default(false) @map("email_verified")
  lastLoginAt     DateTime? @map("last_login_at")
  storageUsedBytes BigInt   @default(0) @map("storage_used_bytes")
  storageLimitBytes BigInt  @default(2147483648) @map("storage_limit_bytes") // 2GB default
  
  // Settings (JSONB)
  settings        Json      @default("{}")
  
  // Relations
  papers          Paper[]
  collections     Collection[]
  annotations     Annotation[]
  sessions        Session[]
  syncLogs        SyncLog[]
  
  @@index([email])
  @@map("users")
}

// Papers Table
model Paper {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  
  // Paper metadata
  title           String    @db.VarChar(500)
  authors         String[]  @default([])
  year            Int?
  journal         String?   @db.VarChar(255)
  doi             String?   @unique
  abstract        String?   @db.Text
  tags            String[]  @default([])
  status          String    @default("To Read") @db.VarChar(50)
  relatedPaperIds Int[]    @default([]) @map("related_paper_ids")
  
  // File reference
  pdfUrl          String?   @db.VarChar(500) @map("pdf_url")
  pdfSizeBytes    BigInt?   @map("pdf_size_bytes")
  
  // Notes (rich text HTML)
  notes           String?   @db.Text
  
  // Reading progress (JSONB)
  readingProgress Json?     @map("reading_progress")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  // Sync metadata
  clientId        String?   @db.VarChar(100) @map("client_id")
  version        Int       @default(1)
  deletedAt      DateTime? @map("deleted_at")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  annotations    Annotation[]
  
  @@index([userId])
  @@index([userId, status])
  @@index([doi])
  @@index([userId, updatedAt])
  @@index([deletedAt])
  @@map("papers")
}

// Collections Table
model Collection {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  
  name            String    @db.VarChar(255)
  icon            String    @default("folder") @db.VarChar(50)
  color           String    @default("text-primary") @db.VarChar(50)
  
  // Filter criteria (JSONB)
  filters         Json
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  deletedAt       DateTime? @map("deleted_at")
  version         Int       @default(1)
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([userId, updatedAt])
  @@map("collections")
}

// Annotations Table
model Annotation {
  id              Int       @id @default(autoincrement())
  paperId         Int       @map("paper_id")
  userId          Int       @map("user_id")
  
  // Annotation data
  type            String    @db.VarChar(50) // 'highlight', 'note', 'bookmark'
  pageNumber      Int?      @map("page_number")
  position        Json?     // {x, y, width, height} for highlights
  content         String?   @db.Text
  color           String?   @db.VarChar(50)
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  deletedAt       DateTime? @map("deleted_at")
  version         Int       @default(1)
  
  // Relations
  paper           Paper     @relation(fields: [paperId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([paperId])
  @@index([userId])
  @@map("annotations")
}

// Sessions Table
model Session {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  tokenHash       String    @unique @map("token_hash")
  deviceName      String?   @db.VarChar(255) @map("device_name")
  userAgent       String?   @db.Text @map("user_agent")
  ipAddress       String?   @db.VarChar(45) @map("ip_address")
  createdAt       DateTime  @default(now()) @map("created_at")
  expiresAt       DateTime  @map("expires_at")
  lastActivityAt  DateTime  @default(now()) @updatedAt @map("last_activity_at")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([tokenHash])
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

// Sync Log Table (for debugging)
model SyncLog {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  entityType      String?   @db.VarChar(50) @map("entity_type") // 'paper', 'collection', 'annotation'
  entityId        Int?      @map("entity_id")
  action          String?   @db.VarChar(50) // 'create', 'update', 'delete'
  clientId        String?   @db.VarChar(100) @map("client_id")
  syncedAt        DateTime  @default(now()) @map("synced_at")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([syncedAt])
  @@map("sync_logs")
}

